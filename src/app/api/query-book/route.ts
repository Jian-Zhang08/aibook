import { NextRequest, NextResponse } from 'next/server';
import { join } from 'path';
import { existsSync } from 'fs';
import { AIResponse } from '@/components/AnswerDisplay';

/**
 * Directory where uploaded books are stored
 */
const UPLOADS_DIR = join(process.cwd(), 'uploads');
const SAMPLES_DIR = join(process.cwd(), 'public', 'samples');

/**
 * API endpoint for querying books with AI responses
 */
export async function POST(request: NextRequest) {
  try {
    const { question, bookId } = await request.json();

    if (!question || !bookId) {
      return NextResponse.json(
        { error: 'Question and book ID are required' },
        { status: 400 }
      );
    }

    // Try to find the book file
    const possiblePaths = [
      join(UPLOADS_DIR, `${bookId}.pdf`),
      join(SAMPLES_DIR, `${bookId}.pdf`),
      join(SAMPLES_DIR, 'the-great-gatsby.pdf'), // Fallback for demo
    ];

    let bookPath: string | null = null;
    for (const path of possiblePaths) {
      if (existsSync(path)) {
        bookPath = path;
        break;
      }
    }

    if (!bookPath) {
      return NextResponse.json(
        { error: 'Book not found' },
        { status: 404 }
      );
    }

    // For now, return a mock response
    // In a real implementation, you would:
    // 1. Load the book content
    // 2. Use AI to generate a response
    // 3. Return the structured response

    const mockResponse: AIResponse = {
      responseType: 'text',
      text: `This is a mock response to your question: "${question}". In a real implementation, this would be generated by AI based on the book content.`
    };

    return NextResponse.json(mockResponse, { status: 200 });

  } catch (error) {
    console.error('Error querying book:', error);
    return NextResponse.json(
      { error: 'Failed to query book' },
      { status: 500 }
    );
  }
}